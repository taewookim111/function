/*
함수란?
일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의
실행단위로 정의한 것
즉, 미리 function키워드로 자주쓰는 코드들을 묶어주는 행위
=> 위치하고 상관이 없음(정적스코프를 따르기 때문에) = 함수선언문일경우

함수 호출, 참조 : 미리 정의되어 있는 함수를 식별자를 호출해야 실행됨

함수를 사용하는 이유 : 
함수로 일련의 과정을 하나의 실행단위로 정의하면, 여러번 같은 내용을
호출할 때마다 사용할 수 있습니다. 즉 코드를 재사용할 수 있습니다
재사용성이 높은 함수는 유지보수의 편의성과 같은 코드를 여러번쓰면서
생길수 있는 실수를 줄여서 코드의 신뢰성을 높일 수 있습니다

함수는 일급객체이다, 따라서 이름(식별자)를 붙일 수 있으며,
함수이름을 지을 때 변수를 지을 때 처럼 식별자를 보고도 기능을 유추할 수
있어야 합니다. 함수 중에서 이름이 없을 수도 있는데 그것을
무명, 익명함수라고 합니다

함수 리터럴 : 함수 리터럴은 function이라는 키워드, 함수 이름,
매개변수목록, 함수본체 이렇게 4가지의 구성으로 된 함수를 식별할 수
있는 리터럴을 의미합니다 이 리터럴의 평가값은 객체입니다

인수, 인자( argument ) : 함수를 호출할 때 함수 내부로 넘기는 값을
의미합니다
예) 자판기 내부의  동전을 넣는 구멍, 행위
매개변수 ( parameter ) : 함수를 정의할 때 넘겨받을 값을 사용하기 위해
함수 내부에서 정의하는 변수를 의미합니다
예) 자판기 내부의  동전들어가는 통로
function greet(name, place){
    console.log(`Hello ${name}! Welcome to ${place}!!!`);
}

greet("태우", "우리인재개발원");

함수를 생성방법 : 함수의 정의를 통해서 생성하는데 방법은 여러가지 있습니다

1. 함수 선언문
함수선언문은 리터럴과 형태가 동일합니다, 단 함수선언문은 함수이름을
생략할 수 없습니다
이 때 함수선언문으로 만들어진 함수는 표현식이 아니라 문입니다
function test(){ console.log("test") };
test();
function add(x,y){return x + y};
console.log(add(3,4));


function test() { console.log("test") };
test();

(function test() { console.log("test") })
//표현식이 아니라는 방증
test2();
해당 함수이름만 선언하고 변수는 선언하지 않았음에도
함수선언문은 변수를 가진것처럼 사용되는데 그 이유는
(= 함수선언문으로도 함수가 호출이 되는 이유는)
함수 선언문으로도 함수가 호출이 되는이유는
암묵적으로 변수이름을 자바스크립트가 함수이름과 같은 이름으로
생성하기 때문입니다 (=> 함수의 호이스팅이 일어남)

2. 함수 표현식
자바스크립트에서는 함수가 일급객체라고 했습니다, 즉 함수는 값처럼
변수에 할당할 수도 있고, 객체 안에 프로퍼티로도 존재할 수 있으며
(이때는 메소드라고 부름), 즉 값으로 취급되어 자유롭게 사용이 가능함
let add = function(){}

let add1 = function add1(){}

함수 표현식이 함수 선언문과 차이점
=> 호이스팅 문제
함수표현식은 변수에 담겨져 있기 때문에 변수 호이스팅은 일어남
하지만 변수에 담긴 함수의 식별자는 호이스팅되지 않음
반면 함수 선언문은 자바스크립트가 암묵적(자동으로)으로 변수이름을
정해주기 때문에 이미 함수의 존재를 알고 시작하며, 즉 함수호이스팅이
일어난다
따라서 함수 선언문은 선언전에 사용해도 오류가 나지 않지만,
함수 표현식은 반드시 함수표현식 이후 참조 또는 호출해야합니다

3. 화살표 함수 
Es6이후 도입된 함수생성방법, 키워드 function대신 => 으로 간략하게
선언할 수 있습니다. 다만 화살표함수는 모두 항상 익명함수로 정의됩니다
함수선언문으로는 정의할 수 없고 표현식으로만 정의되며, 주로
콜백함수로 사용할 때 유용합니다

const arrow = ()=>{};
const arr = x=>{ console.log(x) };
//매개 변수가 1개만 있는 경우 ()을 생략할 수 있다
const arr2 = x => x**2;
//{}중괄호도 생략이 가능한데 이때 함수 몸체 내부의 문이 표현식이 아닌
// 문이면 에러가 발생합니다
const power = ()=>const x = 1
const power = ()=>{const x = 1}
//const x = 1; 은 표현식이 아닌 문으로써(변수에 담을 수 없기 때문에)
//{}을 생략할 수 없습니다

함수호출시 주의점
인수확인
// function add(x,y){
//     return x + y
// }
// console.log(add(2));//매개변수의 갯수가 맞지 않음
// console.log(add("a","b"));//매개변수가 개발자가 원하는 데이터타입과다름
//1) 자바스크립트는 매개변수와 인수의 갯수가 일치하는지 상관안함
//2) 자바스크립트는 동적언어이기 때문에 타입을 사전에 정의할 수 없음
//결론적으로 함수를 정의할때 반드시 적절한 인수가 들어오는지
//확인하는 작업이 필요합니다
function add(x,y){
    //인수확인작업
    //x의 데이터타입이 숫자가 아니거나, y의 데이터타입이 숫자가 아니거나
    if(typeof x !== "number" || typeof y !== "number"){
            //console.log("인수는 모두 숫자값을 넣어주세요");
            throw new TypeError("인수를 모두 숫자로 쓰세요")
        }

    return x + y
}
console.log(add(2));
console.log(add("a","b"));

함수 반환값(return)
function plus(num1, num2){
    let result = num1 + num2;
    //함수 내부에서만 적용하고 휘발된 상황
    return result;
    //리턴을 안해주면 값은 undefined가 된다
     console.log("안녕")//이 값은 출력되지 않는다 return때문에
}
console.log(plus(2, 3));
-함수내부의 값을 함수 외부로 반환하는 것이다
함수 안에서 내보내고 싶은 값 앞에 return키워드를 붙여줌
(반환문은 return키워드 뒤에오는 표현식을 평가하고 외부로 반환)
-리턴값을 쓰는 이유는 해당 함수의 결과값을 다시 다른곳에서
재활용할 수 있기때문입니다
-함수 내부에서 구문 실행도중에 return문을 만나면 강제로 함수가
종료됨(따라서 반환문 이후 다른 문은 실행하지 않고 무시됩니다)

함수의 형태
1. 즉시실행 함수
함수의 정의와 동시에 즉시 호출되는 함수를 의미합니다
이 함수는 한번만 호출되고 다시 호출할 수 없습니다
사용방법은 그룹연산자()로 감싸고, 함수실행할때 사용하는방법인
()으로 마무리 짓는다
(function test(){})();
 (function test(){}());
 이렇게 그룹연산자로 묶는 이유는
 먼저 함수리터럴을 평가해서 함수 객체를 생성해야 사용할 수 있기 때문
 let f = (function add(){
    let a = 3;
    let b = 4;
    return a + b;
})();
console.log(f);
//즉시실행함수도 일반함수처럼 값을 반환할 수 있다
let res = (function(a, b){
    return a - b;
})(5, 3);
console.log(res);
//즉시실행함수도 일반함수처럼 인수를 전달할 수 있다

2. 중첩함수
함수 내부에 정의된 함수를 중첩함수 또는 내부함수라고 합니다
이 중첩함수를 포함한 함수를 외부함수라고 합니다
중첩(내부)함수는 외부함수 안에서만 호출할 수 있으며,
보통 이 중첩함수의 역할은 외부함수를 돕는 도우미의 역할을 합니다
외부함수가 내부함수를 생성하는 목적은
외부함수의 기능을 분리하거나, 스코프를 나누거나 하는 것입니다
function outer(){
    let x = 1;
    function inner(){
        let y = 3;
        console.log(x + y);
        //내부함수는 외부함수의 변수를 사용할 수 있습니다
    }
    inner();
}
outer();
inner(); //레퍼런스 에러, 내부함수는 외부함수 안에서만 사용가능

3. 콜백함수
함수의 매개변수를 통해서 다른 함수의 내부로 전달되는 함수를 말합니다
매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수는
고차함수라고 합니다
중첩함수 - 외부함수
콜백함수 - 고차함수는 헬퍼의 역할을 합니다
콜백함수는 고차함수에 의해서 호출되기 때문에,
"고차 함수에 콜백함수를 사용(호출)이 아니라 콜백함수 자체가
전달되어야 합니다"
//기존에 배운 고차함수 map

const arr = [1,2,3];
let res = arr.map((el, index)=>{ return el * 2 });
//map메소드 하는 역할은 arr의 요소하나하나를 순차적으로 접근한다
//접근한 요소에게 콜백함수를 적용한다
//적용이 완료된 값을 모아서 배열로 반환한다
console.log(res); //[2, 4, 6]

4. 재귀함수
함수가 자기자신을 호출하는 것을 재귀호출이라고 하고
재귀함수는 자신을 호출하는 행위, 즉 재귀호출을 하는 함수를 말한다
반복문과 비슷한 효과를 가져올 수 있습니다, 즉 재귀함수로도
잘 사용하면 반복처리되는 효과를 가질 순 있지만, 잘 사용하지 않아요
재귀함수는 자신을 무한하게 재귀호출하므로
반드시 탈출조건을 만들어야합니다
그렇지 않으면 함수가 무한 호출되어 에러가 발생합니다
지금은 개념만 배우고 실제사용은 requestAnimationFrame을 실습할때
예제를 통해 학습하겠습니다

5. 순수함수와 비순수함수
순수함수란? 어떠한 외부상태에 의존하지 않고,
외부상태를 변경하지도 않아서 함수가 부수적인 효과가 없으며,
결과적으로 항상 일정한/같은 값을 반환하여 개발자가 예측이 가능한 함수
비순수함수란?
반대로 외부에 의존하거나, 외부상태를 변경시키거나하는
부수적인 효과가 있어서 외부에 따라 다른 값을 반환하는 함수를 말한다
따라서 개발자의 예측이 어렵다

*/

// let count = 0;
// function plus(n){
//     return ++n;
// }
// count = plus(count);
// console.log(count);
//외부값인 count와 독립적이며, 반환하는 값도 예측이 가능합니다
//count의 변경은 함수내부가 아닌 외부에서 count가 변경이됩니다

let count = 0;
function plus(){
    return ++count;
    //외부변수인 count에 종속적이되며, 외부상태인 외부변수
    //count를 직접변경합니다
}
plus();
console.log(count);
//외부상태를 직접변경했기때문에 현재의 값을 바로 예측하기 어렵
